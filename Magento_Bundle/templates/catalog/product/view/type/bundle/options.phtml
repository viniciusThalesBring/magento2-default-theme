<?php
/**
 * Hyvä Themes - https://hyva.io
 * Copyright © Hyvä Themes 2020-present. All rights reserved.
 * This product is licensed per Magento install
 * See https://hyva.io/license
 */

declare(strict_types=1);

use Hyva\Theme\Model\ViewModelRegistry;
use Hyva\Theme\ViewModel\ProductPage;
use Magento\Bundle\Block\Catalog\Product\View\Type\Bundle;
use Magento\Framework\Escaper;

/** @var Bundle $block */
/** @var Escaper $escaper */
/** @var ViewModelRegistry $viewModels */

$product = $block->getProduct();
$stripSelection = $product->getConfigureMode() ? true : false;
$options = $block->decorateArray($block->getOptions($stripSelection));

/** @var ProductPage $productViewModel */
$productViewModel = $viewModels->require(ProductPage::class);

?>
<?php if ($product->isSaleable()): ?>
<div class="card flex w-full sm:w-1/2 lg:w-2/3">
    <?php if (count($options)): ?>
        <script>
            function initBundleOptions() {
                return {
                    optionConfig: <?= /* @noEscape */ $block->getJsonConfig() ?>,
                    productFinalPrice: false,
                    activeSelectOptions: {},
                    selectedOptions: [],
                    getMultiOptionQty(option, optionSelection) {
                        if (option.isMulti) {
                            return optionSelection.qty;
                        }
                        return false;
                    },
                    calculateTotalPrice() {
                        const $refs = this.$refs;
                        let selectedProductsPerOption = [];

                        for (const [optionId, option] of Object.entries(this.optionConfig.options)) {
                            const optionCode = 'option-' + optionId;
                            const optionRef = $refs[optionCode];
                            const qtyRef = $refs[optionCode+'-qty'];

                            let selectedOption = selectedProductsPerOption[optionId] || [];

                            if (optionRef) {
                                if (optionRef.checked || optionRef.selected) {
                                    const optionSelection = option.selections[optionRef.dataset.selectionId];
                                    selectedOption.push({
                                        data: optionSelection,
                                        qty: this.getMultiOptionQty(option, optionSelection) ||
                                            (qtyRef && qtyRef.value) || 1
                                    });
                                }
                            } else {
                                for (const [selectionId, selection] of Object.entries(option.selections)) {
                                    const selectionCode = optionCode + '-' + selectionId;
                                    const selectionRef = $refs[selectionCode];
                                    if(
                                        selectionRef &&
                                        (
                                            selectionRef.checked ||
                                            selectionRef.selected
                                        )
                                    ) {
                                        selectedOption.push({
                                            data: selection,
                                            qty: this.getMultiOptionQty(option, selection) ||
                                                (qtyRef && qtyRef.value) || 1
                                        });
                                    }
                                }
                            }

                            selectedProductsPerOption[optionId] = Object.assign(
                                [],
                                selectedProductsPerOption[optionId],
                                selectedOption
                            );
                        }

                        this.productFinalPrice = Object.values(selectedProductsPerOption)
                            .reduce(
                                (totalPrice, option) => {
                                    let oldPrice = totalPrice.oldPrice;
                                    let finalPrice = totalPrice.finalPrice;

                                    const totalOptionPrice = Object.values(option).reduce(
                                        (optionPrice, product) => {
                                            let oldPrice = optionPrice.oldPrice;
                                            let finalPrice = optionPrice.finalPrice;

                                            let lowestPrice = product.data.prices;

                                            lowestPrice = product.data.tierPrice.reduce((finalValue, tierPrice) => {
                                                if (product.qty >= tierPrice.price_qty) {
                                                    return (
                                                        tierPrice.prices.finalPrice.amount <
                                                        lowestPrice.finalPrice.amount
                                                    ) ?
                                                    tierPrice.prices :
                                                    finalValue;
                                                }
                                                return finalValue;
                                            }, lowestPrice);

                                            // check lowest price for qty
                                            oldPrice = oldPrice + (
                                                lowestPrice.oldPrice.amount * product.qty
                                            );
                                            finalPrice = finalPrice + (
                                                lowestPrice.finalPrice.amount * product.qty
                                            );

                                            return { oldPrice, finalPrice };
                                        }, { 'oldPrice': 0, 'finalPrice': 0 }
                                    );

                                    return {
                                        oldPrice: oldPrice + totalOptionPrice.oldPrice,
                                        finalPrice: finalPrice + totalOptionPrice.finalPrice
                                    }

                                },
                                { 'oldPrice': 0, 'finalPrice': 0 }
                            );

                        this.selectedOptions = Object.keys(selectedProductsPerOption).map((optionId) => {
                            return {
                                label: this.optionConfig.options[optionId].title,
                                products: Object.values(selectedProductsPerOption[optionId]).map( product => {
                                    return {
                                        qty: product.qty,
                                        name: product.data.name
                                    }
                                })
                            }
                        });

                        this.dispatchFinalPrice();
                        this.dispatchOptionSelection();
                    },
                    dispatchFinalPrice() {
                        window.dispatchEvent(
                            new CustomEvent(
                                "update-bundle-option-prices",
                                { detail: this.productFinalPrice }
                            )
                        );
                    },
                    dispatchOptionSelection() {
                        window.dispatchEvent(
                            new CustomEvent(
                                "update-bundle-option-selection",
                                { detail: this.selectedOptions }
                            )
                        );
                    }
                }
            }
            </script>
        <div x-data="initBundleOptions()"
             x-init="
                calculateTotalPrice();
                $nextTick(() => {
                    dispatchFinalPrice();
                    dispatchOptionSelection();
                    $dispatch('set-selected-options', {});
                })
             ">

            <fieldset class="fieldset fieldset-bundle-options" form="product_addtocart_form">
                <legend id="customizeTitle" class="legend mb-2">
                    <h3 class="text-gray-900 text-2xl title-font font-base text-center md:text-left w-full">
                        <?= $escaper->escapeHtml(__('Customize %1', $product->getName())) ?>
                    </h3>
                </legend>
                <?= $block->getChildHtml('product_info_bundle_options_top') ?>
                <?php foreach ($options as $option): ?>
                    <?php
                    if (!$option->getSelections()) {
                        continue;
                    } ?>
                    <div class="my-2 pt-4 pb-2 w-full border-t border-container">
                        <label class="label text-lg font-semibold">
                            <span><?= $escaper->escapeHtml($option->getTitle()) ?></span>
                        </label>
                        <div class="control mt-2">
                            <div class="nested options-list">
                                <?= $block->getOptionHtml($option); ?>
                            </div>
                        </div>
                    </div>
                <?php endforeach; ?>
            </fieldset>
        </div>
    <?php else: ?>
        <p class="empty"><?= $escaper->escapeHtml(__('No options of this product are available.')) ?></p>
    <?php endif; ?>
</div>
    <?php endif;?>

